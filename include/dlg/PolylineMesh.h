/* Auto-generated by genmsg_cpp for file /work/ros/pkgs-trunk/point_cloud_perception/pcl/msg/PolylineMesh.msg */
#ifndef PCL_MESSAGE_POLYLINEMESH_H
#define PCL_MESSAGE_POLYLINEMESH_H
#include <string>
#include <vector>
#include <ostream>

// Include the correct Header path here
#include <pcl/PCLHeader.h>
#include <pcl/PCLPointCloud2.h>
#include <pcl/point_cloud.h>
#include <pcl/Vertices.h>

#include <pcl/io/obj_io.h>
#include <fstream>
#include <iostream>
#include <pcl/common/io.h>
#include <pcl/io/boost.h>
#include <boost/lexical_cast.hpp>
#include <boost/graph/graph_concepts.hpp>
#include <pcl/console/time.h>

#include <pcl/conversions.h>

#define MAX_VERTEX_NUM 9999999 
#define MAX_NAME 2 


namespace pcl
{
typedef int Infortype;  
typedef int VertexType;  
typedef enum{ DG, DN, AG, AN } GraphKind; //图形种类{有向图，有向网，无向图，无向网}  
  
typedef struct _ArcNode  
{  
    int adjvex;        //该弧指向的顶点的位置  
    struct _ArcNode *nextarc;  //指向下一条弧的指针  
    Infortype *info;           //该弧的相关信息  
}ArcNode;  
  
typedef struct _VNode  
{  
    VertexType data;             //顶点信息  
    ArcNode *firstarc;           //指向第一条依附该顶点的狐的指针  
}VNode, AdjList[MAX_VERTEX_NUM];  
  
typedef struct _ALGraph  
{  
    AdjList vertices;  
    int vexnum, arcnum;  //弧的当前顶点数和弧数  
    int kind;  
}ALGraph;  

//邻接表存储Graph类  
class Graph  
{  
private:  
    ALGraph G;  
public:  
    //求顶点在图中的位置 
    PCL_EXPORTS int
    LocateVex( ALGraph G, VertexType u );   
    //构造没有相关信息的无向图  
    PCL_EXPORTS int
    CreateGraph( ALGraph &G );      
    //销毁图G  
    void DestroyGraph( ALGraph &G );     
    //返回序号是v的顶点值  
    VertexType GetVex( ALGraph G, int v );         
    //对v赋新值value  
    void PutVex( ALGraph &G, VertexType v, VertexType value );  
    //返回v的第一个邻接顶点的序号  
    int FirstAdjVex( ALGraph G, VertexType v );  
    //返回v的（相对于w的）下一个邻接顶点的序号  
    int NextAdjVex( ALGraph G, VertexType v, VertexType w );  
    //在图G中增加新顶点v  
    void InsertVex( ALGraph &G, VertexType v );  
    //删除图G顶点v及其相关的弧  
    void DeleteVex( ALGraph &G, VertexType v );  
    //在G中增加弧<v,w>  
    void InsertArc( ALGraph &G, VertexType v, VertexType w );  
    //在图G中删除弧<v,w>  
    void DeleteArc( ALGraph &G, VertexType v, VertexType w );  
    //从第v个顶点出发递归深度优先遍历图G  
    void DFS( ALGraph g, int v );  
    //从第1个顶点出发深度优先遍历图G  
    void DFSTraverse( ALGraph G );  
    //从第1个顶点出发广度优先遍历图G  
    void BFSTraverse( ALGraph G );  
    //输出图G  
    PCL_EXPORTS int
    Display( ALGraph G );  
};  
  
  //template<typename PointT>
  struct PolylineMesh
  {
    PolylineMesh () : header (), cloud (),cloud_vertices(new pcl::PointCloud<pcl::PointWithRange>), polylines ()
    {
    }

    ::pcl::PCLHeader  header;

    ::pcl::PCLPointCloud2 cloud;
    ::pcl::PointCloud<pcl::PointWithRange> PointCloud2;
    pcl::PointCloud<pcl::PointWithRange>::Ptr cloud_vertices;
    //typedef pcl::PointCloud<PointT> PointCloud;

    std::vector< ::pcl::Vertices>  polylines;

  public:
    typedef boost::shared_ptr< ::pcl::PolylineMesh> Ptr;
    typedef boost::shared_ptr< ::pcl::PolylineMesh const> ConstPtr;
  }; // struct PolylineMesh

  typedef boost::shared_ptr< ::pcl::PolylineMesh> PolylineMeshPtr;
  typedef boost::shared_ptr< ::pcl::PolylineMesh const> PolylineMeshConstPtr;

  inline std::ostream& operator<<(std::ostream& s, const  ::pcl::PolylineMesh &v)
  {
    s << "header: " << std::endl;
    s << v.header;
    s << "cloud: " << std::endl;
    s << v.cloud;
    s << "polylines[]" << std::endl;
    for (size_t i = 0; i < v.polylines.size (); ++i)
    {
      s << "  polylines[" << i << "]: " << std::endl;
      s << v.polylines[i];
    }
    return (s);
  }
  namespace io
  {
    /** \brief Saves a PolylineMesh in ascii OBJ format.
      * \param[in] file_name the name of the file to write to disk
      * \param[in] mesh the polyline mesh to save
      * \param[in] precision the output ASCII precision default 5
      * \ingroup io
      */
    PCL_EXPORTS int
    saveOBJFile2 (const std::string &file_name,
                 const pcl::PolylineMesh &mesh, unsigned precision = 5);
                 
    /** \brief Saves a PolylineMesh in ascii OBJ format.
      * \param[in] file_name the name of the file to write to disk
      * \param[in] mesh the polyline mesh to save
      * \param[in] precision the output ASCII precision default 5
      * \ingroup io
      */
    PCL_EXPORTS int
    saveOBJFile3 (const std::string &file_name,
                 const pcl::PolylineMesh &mesh, unsigned precision = 5);
    
    
  }

} // namespace pcl


int
pcl::io::saveOBJFile2 (const std::string &file_name,
                      const pcl::PolylineMesh &mesh, unsigned precision)
{
  if (mesh.cloud.data.empty ())
  {
    PCL_ERROR ("[pcl::io::saveOBJFile] Input point cloud has no data!\n");
    return (-1);
  }
  // Open file
  std::ofstream fs;
  fs.precision (precision);
  fs.open (file_name.c_str ());

  /* Write 3D information */
  // number of points
  int nr_points  = mesh.cloud.width * mesh.cloud.height;
  // point size
  unsigned point_size = static_cast<unsigned> (mesh.cloud.data.size () / nr_points);
  // number of faces for header
  unsigned nr_faces = static_cast<unsigned> (mesh.polylines.size ());
  // Do we have vertices normals?
  int normal_index = getFieldIndex (mesh.cloud, "normal_x");

  // Write the header information
  fs << "####" << '\n';
  fs << "# OBJ dataFile simple version. File name: " << file_name << '\n';
  fs << "# Vertices: " << nr_points << '\n';
  if (normal_index != -1)
    fs << "# Vertices normals : " << nr_points << '\n';
  fs << "# Lines: " <<nr_faces << '\n';
  fs << "####" << '\n';

  // Write vertex coordinates
  fs << "# List of Vertices, with (x,y,z) coordinates, w is optional." << '\n';
  for (int i = 0; i < nr_points; ++i)
  {
    int xyz = 0;
    for (size_t d = 0; d < mesh.cloud.fields.size (); ++d)
    {
      int c = 0;
      // adding vertex
      if ((mesh.cloud.fields[d].datatype == pcl::PCLPointField::FLOAT32) && (
          mesh.cloud.fields[d].name == "x" ||
          mesh.cloud.fields[d].name == "y" ||
          mesh.cloud.fields[d].name == "z"))
      {
        if (mesh.cloud.fields[d].name == "x")
           // write vertices beginning with v
          fs << "v ";

        float value;
        memcpy (&value, &mesh.cloud.data[i * point_size + mesh.cloud.fields[d].offset + c * sizeof (float)], sizeof (float));
        fs << value;
        if (++xyz == 3)
          break;
        fs << " ";
      }
    }
    if (xyz != 3)
    {
      PCL_ERROR ("[pcl::io::saveOBJFile] Input point cloud has no XYZ data!\n");
      return (-2);
    }
    fs << '\n';
  }

  fs << "# "<< nr_points <<" vertices" << '\n';

  if(normal_index != -1)
  {
    fs << "# Normals in (x,y,z) form; normals might not be unit." <<  '\n';
    // Write vertex normals
    for (int i = 0; i < nr_points; ++i)
    {
      int nxyz = 0;
      for (size_t d = 0; d < mesh.cloud.fields.size (); ++d)
      {
        int c = 0;
        // adding vertex
        if ((mesh.cloud.fields[d].datatype == pcl::PCLPointField::FLOAT32) && (
              mesh.cloud.fields[d].name == "normal_x" ||
              mesh.cloud.fields[d].name == "normal_y" ||
              mesh.cloud.fields[d].name == "normal_z"))
        {
          if (mesh.cloud.fields[d].name == "normal_x")
            // write vertices beginning with vn
            fs << "vn ";

          float value;
          memcpy (&value, &mesh.cloud.data[i * point_size + mesh.cloud.fields[d].offset + c * sizeof (float)], sizeof (float));
          fs << value;
          if (++nxyz == 3)
            break;
          fs << " ";
        }
      }
      if (nxyz != 3)
      {
        PCL_ERROR ("[pcl::io::saveOBJFile] Input point cloud has no normals!\n");
        return (-2);
      }
      fs << '\n';
    }

    fs << "# "<< nr_points <<" vertices normals" << '\n';
  }

  fs << "# Line Definitions" << '\n';
  // Write down lines
  if(normal_index == -1)
  {
    for(unsigned i = 0; i < nr_faces; i++)
    {
      fs << "l ";
      size_t j = 0;
      for (; j < mesh.polylines[i].vertices.size () - 1; ++j)
        fs << mesh.polylines[i].vertices[j] + 1 << " ";
      fs << mesh.polylines[i].vertices[j] + 1 << '\n';
    }
  }
  else
  {
    for(unsigned i = 0; i < nr_faces; i++)
    {
      fs << "l ";
      size_t j = 0;
      for (; j < mesh.polylines[i].vertices.size () - 1; ++j)
        fs << mesh.polylines[i].vertices[j] + 1 << "//" << mesh.polylines[i].vertices[j] + 1 << " ";
      fs << mesh.polylines[i].vertices[j] + 1 << "//" << mesh.polylines[i].vertices[j] + 1 << '\n';
    }
  }
  fs << "# End of File" << std::endl;

  // Close obj file
  fs.close ();
  return 0;
}

int
pcl::io::saveOBJFile3 (const std::string &file_name,
                      const pcl::PolylineMesh &mesh, unsigned precision)
{  
  // Open file
  std::ofstream fs;
  fs.precision (precision);
  fs.open (file_name.c_str ());

  /* Write 3D information */
  // number of points
  int nr_points  = mesh.cloud_vertices->points.size();
  if (nr_points==0)
  {
    PCL_ERROR ("[pcl::io::saveOBJFile] Input point cloud_vertices has no data!\n");
    return (-1);
  }
  // number of faces for header
  unsigned nr_lines = static_cast<unsigned> (mesh.polylines.size ());


  // Write the header information
  fs << "####" << '\n';
  fs << "# OBJ dataFile simple version. File name: " << file_name << '\n';
  fs << "# Vertices: " << nr_points << '\n';
  
  fs << "# Lines: " <<nr_lines << '\n';
  fs << "####" << '\n';

  // Write vertex coordinates
  fs << "# List of Vertices, with (x,y,z) coordinates, w is optional." << '\n';
  
  pcl::PointWithRange pt;
  for (size_t i = 0; i < nr_points; ++i)
  {
    pt=mesh.cloud_vertices->points[i];
     fs << "v"<<" "<<pt.x<<" "<<pt.y<<" "<<pt.z<<'\n';
  }
  fs << "# "<< nr_points <<" vertices" << '\n';

  
  
  fs << "# Line Definitions" << '\n';
  // Write down lines
  for(unsigned i = 0; i < nr_lines; i++)
  {
      fs << "l ";
      size_t j = 0;
      for (; j < mesh.polylines[i].vertices.size () - 1; ++j)
        fs << mesh.polylines[i].vertices[j] + 1 << " ";
      fs << mesh.polylines[i].vertices[j] + 1 << '\n';
  }
  fs << "# End of File" << std::endl;

  // Close obj file
  fs.close ();
  return 0;
}

  

#endif // PCL_MESSAGE_POLYGONMESH_H

